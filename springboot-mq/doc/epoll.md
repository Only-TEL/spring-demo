linux命令

```shell
nc 127.0.0.1 8080 // network connection
man 2 socket // 搜索scoket方法
```

### JNI原理

socket通信 -> 3个socket

1、解析reids server

```c
#include<stdio.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>	
#include "com_Server.h"

JNIEXPORT void JNICALL Java_com_Server_conn(JNIEnv *env, jclass c1){
    // 调用系统socket函数 <- sys/socket.h  lfd:文件描述符
	int lfd = socket(AF_INET,SOCK_STREAM,0); //SOCK_STREAM 表示协议，TCP/IP man 2 socket
	struct sockaddr_in my_addr; 
	my_addr.sin_family = AF_INET;				// ipv4
	my_addr.sin_port   = htons(8080);			// 端口，转为字节
    // INADDR_ANY，表示任意一个可用的网卡地址
	my_addr.sin_addr.s_addr = htonl(INADDR_ANY);// 将127.0.0.1转为ip地址，->字节数组
    // 传入参数，传出参数，传入传出参数
    // 文件描述符，socket socketaddr/socket_in() ip长度
	bind(lfd, (struct sockaddr*)&my_addr, sizeof(my_addr));// man 2 bind
    // 同一时刻可以监听的请求数，最多在一秒内可以监听到128个请求
	listen(lfd, 128);
	printf("listen client @port=%d...\n",8080);
    
	struct sockaddr_in client_addr;		   // 定义就可以
	char cli_ip[INET_ADDRSTRLEN] = "";	   // INET_ADDRSTRLEN 宏定义
	socklen_t cliaddr_len = sizeof(client_addr);    
	int connfd = 0;
    // 创建socket对应文件描述符 client_addr是一个传出参数 客户端地址长度->传入传出参数
	connfd = accept(lfd, (struct sockaddr*)&client_addr, &cliaddr_len);// man 2 accept
    
    // 将结构体转为标准的ip和port，转到cli_ip这个数组中
	inet_ntop(AF_INET, &client_addr.sin_addr, cli_ip, INET_ADDRSTRLEN);
    printf("----------------------------------------------\n");
	printf("client ip=%s,port=%d\n", cli_ip,ntohs(client_addr.sin_port));// 客户端也存在一个端口号，内核隐式分配
	char recv_buf[512] = "";
	while(1) // 一直读
	{	// 读数据到recv_buf
        int k = read(connfd, recv_buf, sizeof(recv_buf));
        printf("recv data=%d\n",k);
        printf("%s\n",recv_buf);
	}
    close(connfd);
    printf("client closed!\n");
    close(lfd); 
}

int main(){
	return 0;
}
```

java类

```java
package com;

public class Server{
	static{
		System.loadLibrary("serverNet");
	}
	public static void main(String[] args) throws Exception{
	    conntect();
	}
	public static native void conntect();
}
```

JNI的步骤

1、装载库，一般在静态块中，类加载时装载

```java
 System.loadLibrary("serverNet");
```

2、编译java文件，使用open-jdk编译

```shell
javac Server.java
```

3、生成 .h 头文件

```shell
javah com.Server # 生成的 .h 文件需要放到包当中
```

4、编写c文件，c文件方法参考 .h 的头文件

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_Server */

#ifndef _Included_com_Server
#define _Included_com_Server
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_Server
 * Method:    conntect
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_Server_conntect (JNIEnv *, jclass);

#ifdef __cplusplus
}
#endif
#endif
```

5、编译动态链接库

```java
gcc -fPIC -I /usr/lib/jvm/java-1.8.0-openjdk/include -I /usr/lib/jvm/java-1.8.0-openjdk/include/linux  -shared -o libserverNet.so Server.c  // lib名称.so 名称.c
```

6、把这个库所在的目录添加到path

```shell
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/data/jni  # 一次性
```

7、运行java文件

```shell
java com.Server
```

8、使用nc命令连接服务器

```shell
nc 127.0.0.1 8080
```

### 传统IO阻塞

```java
byte[] bytes = new byte[1024];
ServerSocket serverSocket = new ServerSocket();
System.out.println("wait connection");
// bind
serverSocket.bind(new InetSocketAddress(8080));
// accept阻塞
Socket accept = serverSocket.accept();
System.out.println("connection success");
// read阻塞
System.out.println("wait data");
accept.getInputStream().read(bytes);
System.out.println("data end");
System.out.println(new String(bytes));
```

Http是长连接还是短连接

```properties
在HTTP/1.1之前，HTTP是短连接
1.1以及1.1之后是一个长连接
```

单线程解决阻塞的问题

### 多路复用IO

```java
List<SocketChannel> list = new ArrayList();
ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
try {
    ServerSocketChannel ssc = ServerSocketChannel.open();
    ssc.bind(new InetSocketAddress(9091));
    ssc.configureBlocking(false);
    while (true){
        SocketChannel socketChannel = ssc.accept();
        if(socketChannel==null){
            Thread.sleep(1000);
            System.out.println("没人连接");
            for (SocketChannel channel : list) {
                int k =channel.read(byteBuffer);
                System.out.println(k);
                if(k!=0){
                    byteBuffer.flip();
                    System.out.println(new String(byteBuffer.array()));
                }
            }
        }else{
            socketChannel.configureBlocking(false);
            list.add(socketChannel);
            //得到套接字，循环所有的套接字，通过套接字获取数据
            for (SocketChannel channel : list) {
                int k =channel.read(byteBuffer);
                System.out.println(k+"=======================================");
                if(k!=0){
                    byteBuffer.flip();
                    System.out.println(new String(byteBuffer.array()));
                }
            }
        }
    }
} catch (Exception e) {
    e.printStackTrace();
}
```

HTTP为什么长连接？

1、如果不发送content-length,数据发出去之后，服务器不会相应，会一直等待客户端发送数据，客户端断了的时候，浏览器反而会显示发送过去的内容

2、如果指定了content-length，则浏览会解析指定的长度后显示出来

以上两个案例说明了HTTP是一个长连接，以为当客户端没有明显/显示的结束时，浏览器会一直等待客户端传输数据完成（js/css/img/xxx）

TCP的三次握手和四次挥手

三次握手

IP协议中存在一定的空间存放syn和ack

客户端					服务端

1、客户端经过路由器找到ip -> 找到目标服务器，通过网络问一下服务器准备好了没有

2、因为TCP是长连接，服务器会回答准备好了，服务器问客户端准备好了没有，这两个数据包可以一起发送过去

3、客户端回答准备好了，至此TCP连接建立完成，可以发送接收数据了

四次挥手

客户端：我关闭发送消息了

服务器：收到

服务器：我也关闭发送消息了

客户端：收到

问题1：为什么服务器的两次回复不能一次发送？

问题2：如果客户端发送最后一个包时间很长，网络问题，导致服务器一直等待的问题？

​	服务器发送了一个包，就必须要等到客户端的回复

服务器会每各一段时间如果没有接受到消息，会再次向客户端发送消息

这时客户端如果把端口给关了会导致传输协议受阻（所以谁先提出关闭的请求的，就会在这个关闭这里会将端口保证在两倍的传输时间内不可用，如果传输最大时间是1分钟，那么这个端口关闭后2分钟内不可用）

如果客户端已经发送了应答包，则不会响应服务端再次发送的关闭消息

测试

```java
byte[] bytes = new byte[1024];
ServerSocket serverSocket = new ServerSocket();
System.out.println("wait connection");
// window下没有timewait状态 在linux下测试才会出现效果
// true表示可以重用,如果设置为false,在客户端关闭TCP连接之后,会出现端口在2分钟内不可用
serverSocket.setReuseAddress(false);
boolean reuseAddress = serverSocket.getReuseAddress();
System.out.println("reuseAddress="+reuseAddress);
// bind
serverSocket.bind(new InetSocketAddress(8080));
// accept阻塞
Socket accept = serverSocket.accept();
System.out.println("connection success");
// read阻塞
System.out.println("wait data");
accept.getInputStream().read(bytes);
System.out.println("data end");
System.out.println(new String(bytes));
```

select

```c
#include<stdio.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>						
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>	

void start(){
    struct sockaddr_in my_addr; 
    my_addr.sin_family = AF_INET;				// ipv4
    my_addr.sin_port   = htons(8080);
    my_addr.sin_addr.s_addr = htonl(INADDR_ANY);//
    struct sockaddr_in client_addr;		   
    char cli_ip[INET_ADDRSTRLEN] = "";	   
    int clientfd = 0;

    int listenfd = socket(AF_INET,SOCK_STREAM,0);
    bind(listenfd, (struct sockaddr*)&my_addr, sizeof(my_addr));
    listen(listenfd, 128);
    printf("listen client @port=%d...\n",8080);
    //connfd = accept(lfd, (struct sockaddr*)&client_addr, &cliaddr_len);
    //inet_ntop(AF_INET, &client_addr.sin_addr, cli_ip, INET_ADDRSTRLEN);
    //printf("----------------------------------------------\n");
    //printf("client ip=%s,port=%d\n", cli_ip,ntohs(client_addr.sin_port));
    int lastfd = listenfd;
    int i;
    fd_set readset,totalSet;
    FD_ZERO(&readset);
    //listenfd 
    FD_SET(listenfd, &totalSet);

    while(1)
    {
        readset = totalSet;
        //setup 1 
        int z = select(lastfd+1,&readset,NULL,NULL,NULL);
        if(z>0){
            
            if(FD_ISSET(listenfd,&readset)){
                socklen_t cliaddr_len = sizeof(client_addr); 
                clientfd = accept(listenfd, (struct sockaddr*)&client_addr, &cliaddr_len);
                inet_ntop(AF_INET, &client_addr.sin_addr, cli_ip, INET_ADDRSTRLEN);
                printf("----------------------------------------------\n");
                printf("client ip=%s,port=%d\n", cli_ip,ntohs(client_addr.sin_port));
                FD_SET(clientfd, &totalSet);	
                lastfd=clientfd;
                if(0==--z){
                    continue;
                }
            }
            for(i=listenfd+1;i<=lastfd;i++){
                if(FD_ISSET(i,&readset)){
                    char recv_buf[512] = "";
                    int rs=read(i,recv_buf,sizeof(recv_buf));
                    if(rs==0){
                        close(i);
                        FD_CLR(i,&totalSet);
                    }else{
                        printf("%s\n",recv_buf);
                        //write(0,recv_buf,rs);
                    }

                }

            }

        }
    }
}
int main(){
	start();
	return 0;
}
```



































